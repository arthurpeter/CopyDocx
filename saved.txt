use warp::Filter;
use warp::http::Response;
use std::fs;
use std::path::PathBuf;
use std::collections::HashMap;
use std::sync::{
    atomic::{AtomicUsize, Ordering},
    Arc,
};
use futures_util::{SinkExt, StreamExt, TryFutureExt};
use tokio::sync::{mpsc, RwLock};
use tokio_stream::wrappers::UnboundedReceiverStream;
use warp::ws::{Message, WebSocket};

/// Our global unique user id counter.
static NEXT_USER_ID: AtomicUsize = AtomicUsize::new(1);

/// Our state of currently connected users.
///
/// - Key is their id
/// - Value is a sender of `warp::ws::Message`
type Rooms = Arc<RwLock<HashMap<String, HashMap<usize, mpsc::UnboundedSender<Message>>>>>; 


#[tokio::main]
async fn main() {
	pretty_env_logger::init();

	let rooms = Rooms::default();
    let rooms_filter = warp::any().map(move || rooms.clone());

	let chat = warp::path("chat")
        .and(warp::ws())
		.and(warp::path::param::<String>())
        .and(rooms_filter)
        .map(|ws: warp::ws::Ws, path: String, rooms| {
            ws.on_upgrade(move |socket| user_connected(socket, path, rooms))
        });

	let save = warp::path("save")
        .and(warp::post())
        .and(warp::body::json())
        .map(|body: HashMap<String, String>| {
            let text = body.get("text").unwrap_or(&"".to_string()).clone();
            let path = body.get("path").unwrap_or(&"".to_string()).clone();
            // Save the text to a file or database with the path
            println!("Saving text for path '{}': {}", path, text);
            // Implement actual saving logic here
            warp::reply::json(&"Save successful")
        });

	let static_files = warp::fs::dir("static");
	let fallback = warp::any()
        .and_then(|| async {
            // Read the contents of `page.html`
            let path = PathBuf::from("static/page.html");
            let contents = fs::read_to_string(&path).unwrap_or_else(|_| "<h1>404 Not Found</h1>".to_string());
            Ok::<_, warp::Rejection>(Response::builder()
                .header("Content-Type", "text/html")
                .body(contents)
                .unwrap())
        });

	let routes = static_files.or(fallback);
	let routes = chat.or(save).or(routes);
	
	println!("Server running on port 8000");
    // Start the warp server
    warp::serve(routes)
        .run(([127, 0, 0, 1], 8000))
        .await;
}

async fn user_connected(ws: WebSocket, path: String, rooms: Rooms) {
    // Generate a unique ID for this user
    let my_id = NEXT_USER_ID.fetch_add(1, Ordering::Relaxed);

    eprintln!("new chat user (ID: {}, Path: {})", my_id, path);

    // Split the socket into a sender and receiver
    let (mut user_ws_tx, mut user_ws_rx) = ws.split();

    // Unbounded channel for buffering messages
    let (tx, rx) = mpsc::unbounded_channel();
    let mut rx = UnboundedReceiverStream::new(rx);

    tokio::task::spawn(async move {
        while let Some(message) = rx.next().await {
            user_ws_tx.send(message).unwrap_or_else(|e| {
                eprintln!("websocket send error: {}", e);
            }).await;
        }
    });

    // Add user to the room
    {
        let mut rooms = rooms.write().await;
        let room = rooms.entry(path.clone()).or_default();
        room.insert(my_id, tx);
    }

    // Handle incoming messages
    while let Some(result) = user_ws_rx.next().await {
        let msg = match result {
            Ok(msg) => msg,
            Err(e) => {
                eprintln!("websocket error (ID: {}): {}", my_id, e);
                break;
            }
        };
        user_message(my_id, msg, &path, &rooms).await;
    }

    // Handle disconnection
    user_disconnected(my_id, &path, &rooms).await;
}

async fn user_message(my_id: usize, msg: Message, path: &str, rooms: &Rooms) {
    let msg = if let Ok(s) = msg.to_str() {
        s
    } else {
        return;
    };

    let new_msg = format!("{}", msg);

    let rooms = rooms.read().await;
    if let Some(room) = rooms.get(path) {
        for (&uid, tx) in room.iter() {
            if my_id != uid {
                if let Err(_disconnected) = tx.send(Message::text(new_msg.clone())) {
                    // Handle disconnected sender
                }
            }
        }
    }
}

async fn user_disconnected(my_id: usize, path: &str, rooms: &Rooms) {
    eprintln!("good bye user (ID: {}, Path: {})", my_id, path);

    let mut rooms = rooms.write().await;
    if let Some(room) = rooms.get_mut(path) {
        room.remove(&my_id);
        if room.is_empty() {
            rooms.remove(path);
        }
    }
}